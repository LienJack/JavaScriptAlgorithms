<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AVL(平衡树)</title>
</head>
<body>
<script>
    class Node {
        constructor(key, value) {
            this.key = key;
            this.value = value;
            this.left = null;
            this.right = null;
            this.height = 1;
        }
    }

    class AVLTree {
        constructor() {
            this.root = null;
            this.size = 0;
        }

        add(key, value) {
            this.root = this._add(this.root, key, value)
        }

        _add(node, key, value) {
            if (node === null) {
                this.size++;
                return new Node(key, value)
            }

            if (value < node.value) {
                node.left = this._add(node.left, key, value)
            } else if (value > node.value) {
                node.right = this._add(node.right, key, value)
            } else {
                node.key = key;
                node.value = value
            }
            node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));

            //计算平衡因子
            let balanceFactor = this.getBalanceFactor(node);

            //平衡维护
            if (balanceFactor > 1 && this.getBalanceFactor(node.left) >= 0) {
                return this.rightRotate(node)
            } else if (balanceFactor < -1 && this.getBalanceFactor(node.right) <= 0) {
                return this.leftRotate(node)
            }

            return node
        }

        // 对节点y进行向右旋转操作，返回旋转后新的根节点x
        //        y                              x
        //       / \                           /   \
        //      x   T4     向右旋转 (y)        z     y
        //     / \       - - - - - - - ->    / \   / \
        //    z   T3                       T1  T2 T3 T4
        //   / \
        // T1   T2
        rightRotate(y) {
            let x = y.left,
                T3 = x.right;
            x.right = y;
            y.left = T3;

            y.height = 1 + Math.max(this.getHeight(y.left), this.getHeight(y.right));
            x.height = 1 + Math.max(this.getHeight(x.left), this.getHeight(x.right));

            return x
        }

        // 对节点y进行向左旋转操作，返回旋转后新的根节点x
        //    y                             x
        //  /  \                          /   \
        // T1   x      向左旋转 (y)       y     z
        //     / \   - - - - - - - ->   / \   / \
        //   T2  z                     T1 T2 T3 T4
        //      / \
        //     T3 T4
        leftRotate(y) {
            let x = y.right,
                T2 = x.left;

            x.left = y;
            y.right = T2;

            y.height = 1 + Math.max(this.getHeight(y.left), this.getHeight(y.right));
            x.height = 1 + Math.max(this.getHeight(x.left), this.getHeight(x.right));

            return x
        }

        isBST() {
            let keys = [];
            this.inOrder(this.root, keys);
            for (let i = 1; i < keys.length; i++) {
                if (keys[i - 1] > keys[i]) return false
            }
            return true
        }

        //获取节点平衡因子
        getBalanceFactor(node) {
            if (node === null) return 0;

            return this.getHeight(node.left) - this.getHeight(node.right)
        }

        getHeight(node) {
            if (node === null) return 0;

            return node.height;
        }

        getSize() {
            return this.size
        }

        isBalanced() {
            return this._isBalanced(this.root)
        }

        _isBalanced(node) {
            if (!node) return true;

            let balanceFactor = this.getBalanceFactor(node);
            if (Math.abs(balanceFactor) > 1) {
                return false
            }
            return this._isBalanced(node.left) && this._isBalanced(node.right)
        }

        inOrder(node, keys) {
            if (!node) return null;

            let pre;
            while (node) {
                if (!node.left) {
                    keys.push(node.key);
                    node = node.right
                } else {
                    pre = node.left;
                    while (pre.right && pre.right !== node) {
                        pre = pre.right
                    }
                    if (!pre.right) {
                        pre.right = node;
                        node = node.left
                    } else {
                        keys.push(node)
                        node = node.right
                    }
                }
            }
        }
    }
</script>
</body>
</html>